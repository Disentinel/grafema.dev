
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Grafema â€” Graph-Driven Development</title>
    <meta name="description" content="Represent your codebase as a queryable graph. Define guarantees, track dependencies, catch violations before they ship.">
    <meta name="theme-color" content="#0a0f14">
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg viewBox='0 0 173 196' xmlns='http://www.w3.org/2000/svg'%3E%3Cg stroke='%235ee7e7' stroke-width='2.5' fill='%235ee7e7'%3E%3Cpath d='M86 3.14 L166.61 49.95 L166.35 68.72 H155.31 L155.06 56.36 L86 16.4 L16.61 58.12 L16.13 139.89 L86 180.58 L154.76 140.3 L155.07 102.45 L92.96 101.98 L92.71 111.75 H82.66 L82.21 90.74 L166.03 91.21 L165.87 147.59 L86 194.12 L4.18 145.43 L4.87 51.79 Z'/%3E%3Cpath d='M86 33.74 L139.59 64.66 L139.59 68.48 H123.01 L86 46.77 L42.67 72.21 L42.28 125.69 L86 150.75 L129.32 125.46 L129.51 116.98 H140.04 L140.14 133 L86 163.65 L30.65 131.75 L30.73 65.89 Z'/%3E%3C/g%3E%3C/svg%3E">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: #0a0f14;
            color: #fff;
            min-height: 100vh;
            overflow-x: hidden;
        }

        #canvas-blur-back,
        #canvas-blur-mid,
        #canvas-sharp {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        #canvas-blur-back {
            z-index: 0;
            filter: blur(8px);
        }

        #canvas-blur-mid {
            z-index: 1;
            filter: blur(3px);
        }

        #canvas-sharp {
            z-index: 2;
        }

        .container {
            position: relative;
            z-index: 1;
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 20px;
        }

        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 24px 40px;
            position: relative;
            z-index: 1;
            transition: opacity 0.5s ease;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .logo-icon {
            width: 40px;
            height: 40px;
            position: relative;
            filter: drop-shadow(0 0 8px rgba(94, 231, 231, 0.6)) drop-shadow(0 0 20px rgba(94, 231, 231, 0.4));
            animation: neonFlicker 4s ease-in-out infinite;
        }

        .logo-icon svg {
            width: 100%;
            height: 100%;
        }

        /* Rounded corners for SVG logos */
        .logo-icon svg g {
            filter: url(#round-corners-small);
        }
        .screensaver svg g {
            filter: url(#round-corners-large);
        }

        .logo-text {
            font-size: 24px;
            font-weight: 500;
            color: #5ee7e7;
            letter-spacing: 0.5px;
            text-shadow: 0 0 10px rgba(94, 231, 231, 0.8), 0 0 30px rgba(94, 231, 231, 0.5), 0 0 50px rgba(94, 231, 231, 0.3);
            animation: neonFlicker 4s ease-in-out infinite;
        }

        @keyframes neonFlicker {
            0%, 100% { opacity: 1; }
            92% { opacity: 1; }
            93% { opacity: 0.8; }
            94% { opacity: 1; }
            96% { opacity: 0.9; }
            97% { opacity: 1; }
        }

        .hero {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: calc(100vh - 180px);
            text-align: center;
            position: relative;
            z-index: 1;
            padding: 40px 20px;
            transition: opacity 0.5s ease;
        }

        h1 {
            font-size: clamp(36px, 6vw, 56px);
            font-weight: 600;
            margin-bottom: 20px;
            background: linear-gradient(180deg, #fff 0%, #a0aab4 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .description {
            color: #8899a6;
            font-size: 18px;
            line-height: 1.6;
            max-width: 600px;
            margin-bottom: 40px;
        }

        .buttons {
            display: flex;
            gap: 16px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .btn {
            padding: 14px 28px;
            border-radius: 8px;
            font-size: 15px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #0891b2 0%, #06b6d4 100%);
            color: #fff;
            border: none;
            box-shadow: 0 4px 20px rgba(6, 182, 212, 0.3);
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 30px rgba(6, 182, 212, 0.4);
        }

        .btn-secondary {
            background: transparent;
            color: #fff;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.05);
            border-color: rgba(255, 255, 255, 0.3);
        }

        .sparkle {
            position: fixed;
            bottom: 40px;
            right: 40px;
            width: 30px;
            height: 30px;
            opacity: 0.6;
            z-index: 1;
            transition: opacity 0.5s ease;
        }

        .sparkle svg {
            width: 100%;
            height: 100%;
            fill: #5ee7e7;
        }

        footer {
            position: relative;
            z-index: 1;
            padding: 24px 40px;
            display: flex;
            justify-content: center;
            gap: 32px;
            transition: opacity 0.5s ease;
        }

        footer a {
            color: #8899a6;
            text-decoration: none;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: color 0.3s ease;
        }

        footer a:hover {
            color: #5ee7e7;
        }

        footer a svg {
            width: 18px;
            height: 18px;
        }

        /* Screensaver mode */
        .screensaver-active header,
        .screensaver-active .hero,
        .screensaver-active footer,
        .screensaver-active .sparkle {
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease;
        }

        .screensaver {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease;
            cursor: pointer;
        }

        .screensaver-active .screensaver {
            opacity: 1;
            pointer-events: auto;
        }

        .screensaver svg {
            width: 200px;
            height: 227px;
            filter:
                drop-shadow(0 0 10px rgba(94, 231, 231, 0.9))
                drop-shadow(0 0 30px rgba(94, 231, 231, 0.7))
                drop-shadow(0 0 60px rgba(94, 231, 231, 0.5))
                drop-shadow(0 0 100px rgba(94, 231, 231, 0.3));
            animation: neonPulse 3s ease-in-out infinite, neonFlickerStrong 6s ease-in-out infinite;
        }

        @keyframes neonPulse {
            0%, 100% {
                filter:
                    drop-shadow(0 0 10px rgba(94, 231, 231, 0.9))
                    drop-shadow(0 0 30px rgba(94, 231, 231, 0.7))
                    drop-shadow(0 0 60px rgba(94, 231, 231, 0.5))
                    drop-shadow(0 0 100px rgba(94, 231, 231, 0.3));
            }
            50% {
                filter:
                    drop-shadow(0 0 15px rgba(94, 231, 231, 1))
                    drop-shadow(0 0 40px rgba(94, 231, 231, 0.8))
                    drop-shadow(0 0 80px rgba(94, 231, 231, 0.6))
                    drop-shadow(0 0 120px rgba(94, 231, 231, 0.4));
            }
        }

        @keyframes neonFlickerStrong {
            0%, 100% { opacity: 1; }
            18% { opacity: 1; }
            18.5% { opacity: 0.4; }
            19% { opacity: 1; }
            19.5% { opacity: 0.7; }
            20% { opacity: 1; }
            55% { opacity: 1; }
            55.5% { opacity: 0.5; }
            56% { opacity: 0.8; }
            56.5% { opacity: 1; }
            80% { opacity: 1; }
            80.3% { opacity: 0.6; }
            80.6% { opacity: 1; }
        }

        .logo {
            cursor: pointer;
        }
    </style>
</head>
<body>
    <!-- SVG filters for rounded corners -->
    <svg width="0" height="0" style="position: absolute;">
        <defs>
            <!-- Small logo filter (gentler) -->
            <filter id="round-corners-small" x="-10%" y="-10%" width="120%" height="120%">
                <feGaussianBlur in="SourceGraphic" stdDeviation="0.8" result="blur" />
                <feColorMatrix in="blur" type="matrix" values="1 0 0 0 0  0 1 0 0 0  0 0 1 0 0  0 0 0 20 -10" />
            </filter>
            <!-- Large logo filter (stronger) -->
            <filter id="round-corners-large" x="-10%" y="-10%" width="120%" height="120%">
                <feGaussianBlur in="SourceGraphic" stdDeviation="1.5" result="blur" />
                <feColorMatrix in="blur" type="matrix" values="1 0 0 0 0  0 1 0 0 0  0 0 1 0 0  0 0 0 20 -10" />
            </filter>
        </defs>
    </svg>

    <canvas id="canvas-blur-back"></canvas>
    <canvas id="canvas-blur-mid"></canvas>
    <canvas id="canvas-sharp"></canvas>

    <header>
        <div class="logo">
            <div class="logo-icon">
                <svg viewBox="0 0 173 196" xmlns="http://www.w3.org/2000/svg">
                    <g stroke="#5ee7e7" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" fill="#5ee7e7">
                        <path d="M86 3.14 L166.61 49.95 L166.35 68.72 H155.31 L155.06 56.36 L86 16.4 L16.61 58.12 L16.13 139.89 L86 180.58 L154.76 140.3 L155.07 102.45 L92.96 101.98 L92.71 111.75 H82.66 L82.21 90.74 L166.03 91.21 L165.87 147.59 L86 194.12 L4.18 145.43 L4.87 51.79 Z"/>
                        <path d="M86 33.74 L139.59 64.66 L139.59 68.48 H123.01 L86 46.77 L42.67 72.21 L42.28 125.69 L86 150.75 L129.32 125.46 L129.51 116.98 H140.04 L140.14 133 L86 163.65 L30.65 131.75 L30.73 65.89 Z"/>
                    </g>
                </svg>
            </div>
            <span class="logo-text">grafema</span>
        </div>
    </header>

    <section class="hero">
        <h1>Graph-Driven Development</h1>
        <p class="description">
            Represent your codebase as a queryable graph.<br>
            Define guarantees, track dependencies, catch violations before they ship.
        </p>
        <div class="buttons">
            <a href="https://github.com/Disentinel/grafema" class="btn btn-secondary" target="_blank" rel="noopener">
                <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/>
                </svg>
                View on GitHub
            </a>
            <a href="https://doi.org/10.5281/zenodo.18247579" class="btn btn-primary" target="_blank" rel="noopener">
                Read the Paper
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M7 17L17 7"/><path d="M7 7h10v10"/>
                </svg>
            </a>
        </div>
    </section>

    <div class="sparkle">
        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
            <path d="M12 0L14 10L24 12L14 14L12 24L10 14L0 12L10 10L12 0Z"/>
        </svg>
    </div>

    <footer>
        <a href="https://linkedin.com/in/disentinel" target="_blank" rel="noopener">
            <svg viewBox="0 0 24 24" fill="currentColor">
                <path d="M20.447 20.452h-3.554v-5.569c0-1.328-.027-3.037-1.852-3.037-1.853 0-2.136 1.445-2.136 2.939v5.667H9.351V9h3.414v1.561h.046c.477-.9 1.637-1.85 3.37-1.85 3.601 0 4.267 2.37 4.267 5.455v6.286zM5.337 7.433c-1.144 0-2.063-.926-2.063-2.065 0-1.138.92-2.063 2.063-2.063 1.14 0 2.064.925 2.064 2.063 0 1.139-.925 2.065-2.064 2.065zm1.782 13.019H3.555V9h3.564v11.452zM22.225 0H1.771C.792 0 0 .774 0 1.729v20.542C0 23.227.792 24 1.771 24h20.451C23.2 24 24 23.227 24 22.271V1.729C24 .774 23.2 0 22.222 0h.003z"/>
            </svg>
            LinkedIn
        </a>
        <a href="mailto:hello@grafema.dev">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <rect x="2" y="4" width="20" height="16" rx="2"/>
                <path d="M22 6l-10 7L2 6"/>
            </svg>
            Contact
        </a>
    </footer>

    <div class="screensaver">
        <svg viewBox="0 0 173 196" xmlns="http://www.w3.org/2000/svg">
            <g stroke="#5ee7e7" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" fill="#5ee7e7">
                <path d="M86 3.14 L166.61 49.95 L166.35 68.72 H155.31 L155.06 56.36 L86 16.4 L16.61 58.12 L16.13 139.89 L86 180.58 L154.76 140.3 L155.07 102.45 L92.96 101.98 L92.71 111.75 H82.66 L82.21 90.74 L166.03 91.21 L165.87 147.59 L86 194.12 L4.18 145.43 L4.87 51.79 Z"/>
                <path d="M86 33.74 L139.59 64.66 L139.59 68.48 H123.01 L86 46.77 L42.67 72.21 L42.28 125.69 L86 150.75 L129.32 125.46 L129.51 116.98 H140.04 L140.14 133 L86 163.65 L30.65 131.75 L30.73 65.89 Z"/>
            </g>
        </svg>
    </div>

    <script>
        // Screensaver toggle
        const logo = document.querySelector('.logo');
        const screensaver = document.querySelector('.screensaver');

        logo.addEventListener('click', () => {
            document.body.classList.add('screensaver-active');
        });

        screensaver.addEventListener('click', () => {
            document.body.classList.remove('screensaver-active');
        });

        // === GLOBAL SETTINGS ===
        const HEX_CORNER_RADIUS = 8; // Corner radius for all hexagons (0 = sharp corners)

        // Apply rounded corners to SVG logos via blur+threshold filter
        const smallBlur = document.querySelector('#round-corners-small feGaussianBlur');
        const largeBlur = document.querySelector('#round-corners-large feGaussianBlur');
        if (smallBlur) smallBlur.setAttribute('stdDeviation', HEX_CORNER_RADIUS * 0.1);
        if (largeBlur) largeBlur.setAttribute('stdDeviation', HEX_CORNER_RADIUS * 0.2);

        // Seeded random number generator
        let seed = 956637;

        // Check URL for seed parameter (for testing other layouts)
        const urlParams = new URLSearchParams(window.location.search);
        if (urlParams.has('seed')) {
            seed = parseInt(urlParams.get('seed'), 10);
            console.log('Seed:', seed);
        }

        function seededRandom() {
            seed = (seed * 1103515245 + 12345) & 0x7fffffff;
            return (seed / 0x7fffffff);
        }

        const canvasBack = document.getElementById('canvas-blur-back');
        const canvasMid = document.getElementById('canvas-blur-mid');
        const canvasSharp = document.getElementById('canvas-sharp');
        const ctxBack = canvasBack.getContext('2d');
        const ctxMid = canvasMid.getContext('2d');
        const ctxSharp = canvasSharp.getContext('2d');

        let width, height;
        let mouseX = 0;
        let mouseY = 0;
        let targetMouseX = 0;
        let targetMouseY = 0;

        const hexagons = [];
        const connections = [];
        const focusRadius = 250;
        const focusTransitionRadius = 150;

        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvasBack.width = canvasMid.width = canvasSharp.width = width;
            canvasBack.height = canvasMid.height = canvasSharp.height = height;
        }

        class Hexagon {
            constructor(x, y, size, layer) {
                this.baseX = x;
                this.baseY = y;
                this.x = x;
                this.y = y;
                this.size = size;
                this.layer = layer;
                this.parallaxFactor = 0.02 + layer * 0.015;
                this.opacity = 0.15 + seededRandom() * 0.5;
                this.rotation = seededRandom() * Math.PI * 2;
                this.rotationSpeed = (seededRandom() - 0.5) * 0.002;
                this.floatOffset = seededRandom() * Math.PI * 2;
                this.floatSpeed = 0.0005 + seededRandom() * 0.001;
                this.floatAmplitude = 5 + seededRandom() * 10;
                this.filled = seededRandom() > 0.7;
                this.glowIntensity = seededRandom();
                this.currentLayer = layer;
                this.targetLayer = layer;
            }

            update(time) {
                const parallaxX = (mouseX - width / 2) * this.parallaxFactor;
                const parallaxY = (mouseY - height / 2) * this.parallaxFactor;

                const floatY = Math.sin(time * this.floatSpeed + this.floatOffset) * this.floatAmplitude;
                const floatX = Math.cos(time * this.floatSpeed * 0.7 + this.floatOffset) * this.floatAmplitude * 0.5;

                this.x = this.baseX + parallaxX + floatX;
                this.y = this.baseY + parallaxY + floatY;
                this.rotation += this.rotationSpeed;

                const distToMouse = Math.hypot(this.x - mouseX, this.y - mouseY);

                if (distToMouse < focusRadius) {
                    this.targetLayer = 2;
                } else if (distToMouse < focusRadius + focusTransitionRadius) {
                    this.targetLayer = 1;
                } else {
                    this.targetLayer = this.layer;
                }

                this.currentLayer += (this.targetLayer - this.currentLayer) * 0.1;
            }

            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);

                const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.size * 2);
                gradient.addColorStop(0, `rgba(94, 231, 231, ${this.opacity * 0.5})`);
                gradient.addColorStop(1, 'rgba(94, 231, 231, 0)');

                if (this.glowIntensity > 0.7) {
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, this.size * 2, 0, Math.PI * 2);
                    ctx.fill();
                }

                ctx.beginPath();
                const vertices = [];
                for (let i = 0; i < 6; i++) {
                    const angle = (Math.PI / 3) * i - Math.PI / 2;
                    vertices.push({
                        x: Math.cos(angle) * this.size,
                        y: Math.sin(angle) * this.size
                    });
                }

                if (HEX_CORNER_RADIUS > 0) {
                    // Draw hexagon with rounded corners using arcTo
                    for (let i = 0; i < 6; i++) {
                        const curr = vertices[i];
                        const next = vertices[(i + 1) % 6];
                        if (i === 0) {
                            // Start from midpoint of first edge
                            const prev = vertices[5];
                            const startX = prev.x + (curr.x - prev.x) * 0.5;
                            const startY = prev.y + (curr.y - prev.y) * 0.5;
                            ctx.moveTo(startX, startY);
                            ctx.arcTo(curr.x, curr.y, next.x, next.y, HEX_CORNER_RADIUS);
                        } else {
                            ctx.arcTo(curr.x, curr.y, next.x, next.y, HEX_CORNER_RADIUS);
                        }
                    }
                } else {
                    // Sharp corners
                    for (let i = 0; i < 6; i++) {
                        if (i === 0) {
                            ctx.moveTo(vertices[i].x, vertices[i].y);
                        } else {
                            ctx.lineTo(vertices[i].x, vertices[i].y);
                        }
                    }
                }
                ctx.closePath();

                if (this.filled) {
                    ctx.fillStyle = `rgba(94, 231, 231, ${this.opacity * 0.15})`;
                    ctx.fill();
                }

                ctx.strokeStyle = `rgba(94, 231, 231, ${this.opacity})`;
                ctx.lineWidth = 1.5;
                ctx.stroke();

                ctx.restore();
            }
        }

        function init() {
            resize();
            hexagons.length = 0;
            connections.length = 0;

            const numHexagons = Math.floor((width * height) / 20000);

            for (let i = 0; i < numHexagons; i++) {
                const x = seededRandom() * width;
                const y = seededRandom() * height;
                const size = 15 + seededRandom() * 35;
                const layer = Math.floor(seededRandom() * 3);
                hexagons.push(new Hexagon(x, y, size, layer));
            }

            hexagons.sort((a, b) => a.layer - b.layer);

            for (let i = 0; i < hexagons.length; i++) {
                const hex1 = hexagons[i];
                for (let j = i + 1; j < hexagons.length; j++) {
                    const hex2 = hexagons[j];
                    const dist = Math.hypot(hex1.baseX - hex2.baseX, hex1.baseY - hex2.baseY);
                    if (dist < 200 && seededRandom() > 0.5) {
                        connections.push({
                            from: hex1,
                            to: hex2,
                            opacity: 0.2 + seededRandom() * 0.4,
                            layer: Math.min(hex1.layer, hex2.layer)
                        });
                    }
                }
            }
        }

        function drawConnections(ctx, layerFilter) {
            connections.forEach(conn => {
                const avgLayer = (conn.from.currentLayer + conn.to.currentLayer) / 2;

                if (layerFilter === 0 && avgLayer >= 0.7) return;
                if (layerFilter === 1 && (avgLayer < 0.7 || avgLayer >= 1.7)) return;
                if (layerFilter === 2 && avgLayer < 1.7) return;

                // Calculate direction and distance
                const dx = conn.to.x - conn.from.x;
                const dy = conn.to.y - conn.from.y;
                const dist = Math.hypot(dx, dy);

                if (dist < conn.from.size + conn.to.size) return;

                // Normalize direction
                const nx = dx / dist;
                const ny = dy / dist;

                // Offset start and end points by hex size (stop at edge)
                const startX = conn.from.x + nx * conn.from.size;
                const startY = conn.from.y + ny * conn.from.size;
                const endX = conn.to.x - nx * conn.to.size;
                const endY = conn.to.y - ny * conn.to.size;

                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.lineTo(endX, endY);
                ctx.strokeStyle = `rgba(94, 231, 231, ${conn.opacity})`;
                ctx.lineWidth = 1.5;
                ctx.stroke();
            });
        }

        function drawGradientOverlay(ctx) {
            const gradient = ctx.createRadialGradient(
                width * 0.5, height * 0.4, 0,
                width * 0.5, height * 0.4, Math.max(width, height) * 0.8
            );
            gradient.addColorStop(0, 'rgba(10, 15, 20, 0)');
            gradient.addColorStop(0.5, 'rgba(10, 15, 20, 0.3)');
            gradient.addColorStop(1, 'rgba(10, 15, 20, 0.8)');

            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, width, height);
        }

        function clearCanvas(ctx) {
            ctx.clearRect(0, 0, width, height);
        }

        function animate(time) {
            ctxBack.fillStyle = '#0a0f14';
            ctxBack.fillRect(0, 0, width, height);
            clearCanvas(ctxMid);
            clearCanvas(ctxSharp);

            mouseX += (targetMouseX - mouseX) * 0.08;
            mouseY += (targetMouseY - mouseY) * 0.08;

            hexagons.forEach(hex => hex.update(time));

            // Draw back layer (blurred)
            drawConnections(ctxBack, 0);
            hexagons.forEach(hex => {
                if (hex.currentLayer < 0.7) {
                    hex.draw(ctxBack);
                }
            });

            // Draw mid layer (slightly blurred)
            drawConnections(ctxMid, 1);
            hexagons.forEach(hex => {
                if (hex.currentLayer >= 0.7 && hex.currentLayer < 1.7) {
                    hex.draw(ctxMid);
                }
            });

            // Draw sharp layer (focused)
            drawConnections(ctxSharp, 2);
            hexagons.forEach(hex => {
                if (hex.currentLayer >= 1.7) {
                    hex.draw(ctxSharp);
                }
            });

            drawGradientOverlay(ctxSharp);

            requestAnimationFrame(animate);
        }

        window.addEventListener('resize', () => {
            resize();
            init();
        });

        window.addEventListener('mousemove', (e) => {
            targetMouseX = e.clientX;
            targetMouseY = e.clientY;
        });

        window.addEventListener('touchmove', (e) => {
            targetMouseX = e.touches[0].clientX;
            targetMouseY = e.touches[0].clientY;
        });

        init();
        targetMouseX = width / 2;
        targetMouseY = height / 2;
        mouseX = targetMouseX;
        mouseY = targetMouseY;
        requestAnimationFrame(animate);
    </script>
</body>
</html>
