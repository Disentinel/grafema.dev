
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Grafema â€” Graph-Driven Development</title>
    <meta name="description" content="Represent your codebase as a queryable graph. Define guarantees, track dependencies, catch violations before they ship.">
    <meta name="theme-color" content="#0a0f14">
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg viewBox='0 0 173 196' xmlns='http://www.w3.org/2000/svg'%3E%3Cg stroke='%235ee7e7' stroke-width='2.5' fill='%235ee7e7'%3E%3Cpath d='M86 3.14 L166.61 49.95 L166.35 68.72 H155.31 L155.06 56.36 L86 16.4 L16.61 58.12 L16.13 139.89 L86 180.58 L154.76 140.3 L155.07 102.45 L92.96 101.98 L92.71 111.75 H82.66 L82.21 90.74 L166.03 91.21 L165.87 147.59 L86 194.12 L4.18 145.43 L4.87 51.79 Z'/%3E%3Cpath d='M86 33.74 L139.59 64.66 L139.59 68.48 H123.01 L86 46.77 L42.67 72.21 L42.28 125.69 L86 150.75 L129.32 125.46 L129.51 116.98 H140.04 L140.14 133 L86 163.65 L30.65 131.75 L30.73 65.89 Z'/%3E%3C/g%3E%3C/svg%3E">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: #0a0f14;
            color: #fff;
            min-height: 100vh;
            overflow-x: hidden;
        }

        #canvas-blur-back,
        #canvas-blur-mid,
        #canvas-sharp {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        #canvas-blur-back {
            z-index: 0;
            filter: blur(8px);
        }

        #canvas-blur-mid {
            z-index: 1;
            filter: blur(3px);
        }

        #canvas-sharp {
            z-index: 2;
        }

        .container {
            position: relative;
            z-index: 1;
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 20px;
        }

        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 24px 40px;
            position: relative;
            z-index: 1;
            transition: opacity 0.5s ease;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .logo-icon {
            width: 40px;
            height: 40px;
            position: relative;
            animation: neonFlicker 4s ease-in-out infinite;
        }

        .logo-icon svg {
            width: 100%;
            height: 100%;
            filter: url(#hex-glow-small);
        }

        /* Rounded corners for SVG logos */
        .logo-icon svg g {
            filter: url(#round-corners-small);
        }
        .screensaver svg g {
            filter: url(#round-corners-large);
        }

        .logo-text {
            font-size: 24px;
            font-weight: 500;
            color: #5ee7e7;
            letter-spacing: 0.5px;
            text-shadow: 0 0 10px rgba(94, 231, 231, 0.8), 0 0 30px rgba(94, 231, 231, 0.5), 0 0 50px rgba(94, 231, 231, 0.3);
            animation: neonFlicker 4s ease-in-out infinite;
        }

        @keyframes neonFlicker {
            0%, 100% { opacity: 1; }
            92% { opacity: 1; }
            93% { opacity: 0.8; }
            94% { opacity: 1; }
            96% { opacity: 0.9; }
            97% { opacity: 1; }
        }

        .hero {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: calc(100vh - 180px);
            text-align: center;
            position: relative;
            z-index: 1;
            padding: 40px 20px;
            transition: opacity 0.5s ease;
        }

        h1 {
            font-size: clamp(36px, 6vw, 56px);
            font-weight: 600;
            margin-bottom: 20px;
            background: linear-gradient(180deg, #fff 0%, #a0aab4 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .description {
            color: #8899a6;
            font-size: 18px;
            line-height: 1.6;
            max-width: 600px;
            margin-bottom: 40px;
        }

        .buttons {
            display: flex;
            gap: 16px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .btn {
            padding: 14px 28px;
            border-radius: 8px;
            font-size: 15px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #0891b2 0%, #06b6d4 100%);
            color: #fff;
            border: none;
            box-shadow: 0 4px 20px rgba(6, 182, 212, 0.3);
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 30px rgba(6, 182, 212, 0.4);
        }

        .btn-secondary {
            background: transparent;
            color: #fff;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.05);
            border-color: rgba(255, 255, 255, 0.3);
        }

        .sparkle {
            position: fixed;
            bottom: 40px;
            right: 40px;
            width: 30px;
            height: 30px;
            opacity: 0.6;
            z-index: 1;
            transition: opacity 0.5s ease;
        }

        .sparkle svg {
            width: 100%;
            height: 100%;
            fill: #5ee7e7;
        }

        footer {
            position: relative;
            z-index: 1;
            padding: 24px 40px;
            display: flex;
            justify-content: center;
            gap: 32px;
            transition: opacity 0.5s ease;
        }

        footer a {
            color: #8899a6;
            text-decoration: none;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: color 0.3s ease;
        }

        footer a:hover {
            color: #5ee7e7;
        }

        footer a svg {
            width: 18px;
            height: 18px;
        }

        /* Screensaver mode */
        .screensaver-active header,
        .screensaver-active .hero,
        .screensaver-active footer,
        .screensaver-active .sparkle {
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease;
        }

        .screensaver {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease;
            cursor: pointer;
        }

        .screensaver-active .screensaver {
            opacity: 1;
            pointer-events: auto;
        }

        .screensaver svg {
            width: 200px;
            height: 227px;
            filter: url(#hex-glow-large);
            animation: neonFlickerStrong 6s ease-in-out infinite;
        }

        @keyframes neonFlickerStrong {
            0%, 100% { opacity: 1; }
            18% { opacity: 1; }
            18.5% { opacity: 0.4; }
            19% { opacity: 1; }
            19.5% { opacity: 0.7; }
            20% { opacity: 1; }
            55% { opacity: 1; }
            55.5% { opacity: 0.5; }
            56% { opacity: 0.8; }
            56.5% { opacity: 1; }
            80% { opacity: 1; }
            80.3% { opacity: 0.6; }
            80.6% { opacity: 1; }
        }

        .logo {
            cursor: pointer;
        }

    </style>
</head>
<body>
    <!-- SVG filters -->
    <svg width="0" height="0" style="position: absolute;">
        <defs>
            <!-- Rounded corners filters -->
            <filter id="round-corners-small" x="-10%" y="-10%" width="120%" height="120%">
                <feGaussianBlur in="SourceGraphic" stdDeviation="0.8" result="blur" />
                <feColorMatrix in="blur" type="matrix" values="1 0 0 0 0  0 1 0 0 0  0 0 1 0 0  0 0 0 20 -10" />
            </filter>
            <filter id="round-corners-large" x="-10%" y="-10%" width="120%" height="120%">
                <feGaussianBlur in="SourceGraphic" stdDeviation="1.5" result="blur" />
                <feColorMatrix in="blur" type="matrix" values="1 0 0 0 0  0 1 0 0 0  0 0 1 0 0  0 0 0 20 -10" />
            </filter>

            <!-- Hex-shaped glow for small logo -->
            <filter id="hex-glow-small" x="-50%" y="-50%" width="200%" height="200%">
                <feMorphology operator="dilate" radius="1" in="SourceGraphic" result="dilated" />
                <feGaussianBlur in="dilated" stdDeviation="2" result="blur1" />
                <feColorMatrix in="blur1" type="matrix" values="1 0 0 0 0  0 1 0 0 0  0 0 1 0 0  0 0 0 0.55 0" result="glow1" />
                <feGaussianBlur in="SourceGraphic" stdDeviation="4" result="blur2" />
                <feColorMatrix in="blur2" type="matrix" values="1 0 0 0 0  0 1 0 0 0  0 0 1 0 0  0 0 0 0.35 0" result="glow2" />
                <feMerge>
                    <feMergeNode in="glow2" />
                    <feMergeNode in="glow1" />
                    <feMergeNode in="SourceGraphic" />
                </feMerge>
            </filter>

            <!-- Hex-shaped glow for large logo -->
            <filter id="hex-glow-large" x="-100%" y="-100%" width="300%" height="300%">
                <feMorphology operator="dilate" radius="1.2" in="SourceGraphic" result="dilated1" />
                <feGaussianBlur in="dilated1" stdDeviation="3" result="blur1" />
                <feColorMatrix in="blur1" type="matrix" values="1 0 0 0 0  0 1 0 0 0  0 0 1 0 0  0 0 0 0.65 0" result="glow1" />
                <feMorphology operator="dilate" radius="0.6" in="SourceGraphic" result="dilated2" />
                <feGaussianBlur in="dilated2" stdDeviation="8" result="blur2" />
                <feColorMatrix in="blur2" type="matrix" values="1 0 0 0 0  0 1 0 0 0  0 0 1 0 0  0 0 0 0.45 0" result="glow2" />
                <feGaussianBlur in="SourceGraphic" stdDeviation="20" result="blur3" />
                <feColorMatrix in="blur3" type="matrix" values="1 0 0 0 0  0 1 0 0 0  0 0 1 0 0  0 0 0 0.25 0" result="glow3" />
                <feMerge>
                    <feMergeNode in="glow3" />
                    <feMergeNode in="glow2" />
                    <feMergeNode in="glow1" />
                    <feMergeNode in="SourceGraphic" />
                </feMerge>
            </filter>
        </defs>
    </svg>

    <canvas id="canvas-blur-back"></canvas>
    <canvas id="canvas-blur-mid"></canvas>
    <canvas id="canvas-sharp"></canvas>

    <header>
        <div class="logo">
            <div class="logo-icon">
                <svg viewBox="0 0 173 196" xmlns="http://www.w3.org/2000/svg">
                    <g stroke="#5ee7e7" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" fill="#5ee7e7">
                        <path d="M86 3.14 L166.61 49.95 L166.35 68.72 H155.31 L155.06 56.36 L86 16.4 L16.61 58.12 L16.13 139.89 L86 180.58 L154.76 140.3 L155.07 102.45 L92.96 101.98 L92.71 111.75 H82.66 L82.21 90.74 L166.03 91.21 L165.87 147.59 L86 194.12 L4.18 145.43 L4.87 51.79 Z"/>
                        <path d="M86 33.74 L139.59 64.66 L139.59 68.48 H123.01 L86 46.77 L42.67 72.21 L42.28 125.69 L86 150.75 L129.32 125.46 L129.51 116.98 H140.04 L140.14 133 L86 163.65 L30.65 131.75 L30.73 65.89 Z"/>
                    </g>
                </svg>
            </div>
            <span class="logo-text">grafema</span>
        </div>
        <nav style="display:flex;align-items:center;gap:24px;">
            <a href="/blog/" style="color:#8899a6;text-decoration:none;font-size:14px;font-weight:500;transition:color 0.3s ease;" onmouseover="this.style.color='#5ee7e7'" onmouseout="this.style.color='#8899a6'">Blog</a>
        </nav>
    </header>

    <section class="hero">
        <h1>Graph-Driven Development</h1>
        <p class="description">
            Represent your codebase as a queryable graph.<br>
            Define guarantees, track dependencies, catch violations before they ship.
        </p>
        <div class="buttons">
            <a href="https://forms.gle/dcKycaQhKbFRq1vr5" class="btn btn-primary" target="_blank" rel="noopener">
                Join the waitlist now!
            </a>
            <a href="https://github.com/Disentinel/grafema" class="btn btn-secondary" target="_blank" rel="noopener">
                <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/>
                </svg>
                View on GitHub
            </a>
            <a href="https://doi.org/10.5281/zenodo.18247579" class="btn btn-secondary" target="_blank" rel="noopener">
                Read the Paper
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M7 17L17 7"/><path d="M7 7h10v10"/>
                </svg>
            </a>
        </div>
    </section>

    <div class="sparkle">
        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
            <path d="M12 0L14 10L24 12L14 14L12 24L10 14L0 12L10 10L12 0Z"/>
        </svg>
    </div>

    <footer>
        <a href="https://linkedin.com/in/disentinel" target="_blank" rel="noopener">
            <svg viewBox="0 0 24 24" fill="currentColor">
                <path d="M20.447 20.452h-3.554v-5.569c0-1.328-.027-3.037-1.852-3.037-1.853 0-2.136 1.445-2.136 2.939v5.667H9.351V9h3.414v1.561h.046c.477-.9 1.637-1.85 3.37-1.85 3.601 0 4.267 2.37 4.267 5.455v6.286zM5.337 7.433c-1.144 0-2.063-.926-2.063-2.065 0-1.138.92-2.063 2.063-2.063 1.14 0 2.064.925 2.064 2.063 0 1.139-.925 2.065-2.064 2.065zm1.782 13.019H3.555V9h3.564v11.452zM22.225 0H1.771C.792 0 0 .774 0 1.729v20.542C0 23.227.792 24 1.771 24h20.451C23.2 24 24 23.227 24 22.271V1.729C24 .774 23.2 0 22.222 0h.003z"/>
            </svg>
            LinkedIn
        </a>
        <a href="mailto:hello@grafema.dev">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <rect x="2" y="4" width="20" height="16" rx="2"/>
                <path d="M22 6l-10 7L2 6"/>
            </svg>
            Contact
        </a>
    </footer>

    <div class="screensaver">
        <svg viewBox="0 0 173 196" xmlns="http://www.w3.org/2000/svg">
            <g stroke="#5ee7e7" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" fill="#5ee7e7">
                <path d="M86 3.14 L166.61 49.95 L166.35 68.72 H155.31 L155.06 56.36 L86 16.4 L16.61 58.12 L16.13 139.89 L86 180.58 L154.76 140.3 L155.07 102.45 L92.96 101.98 L92.71 111.75 H82.66 L82.21 90.74 L166.03 91.21 L165.87 147.59 L86 194.12 L4.18 145.43 L4.87 51.79 Z"/>
                <path d="M86 33.74 L139.59 64.66 L139.59 68.48 H123.01 L86 46.77 L42.67 72.21 L42.28 125.69 L86 150.75 L129.32 125.46 L129.51 116.98 H140.04 L140.14 133 L86 163.65 L30.65 131.75 L30.73 65.89 Z"/>
            </g>
        </svg>
    </div>

    <script>
        // Screensaver toggle
        const logo = document.querySelector('.logo');
        const screensaver = document.querySelector('.screensaver');

        logo.addEventListener('click', () => {
            document.body.classList.add('screensaver-active');
        });

        screensaver.addEventListener('click', () => {
            document.body.classList.remove('screensaver-active');
        });

        // Intro: start in screensaver mode, exit after 1 second
        document.body.classList.add('screensaver-active');
        setTimeout(() => {
            document.body.classList.remove('screensaver-active');
        }, 1000);

        // === GLOBAL SETTINGS ===
        const HEX_CORNER_RADIUS = 8; // Corner radius for all hexagons (0 = sharp corners)

        // Apply rounded corners to SVG logos via blur+threshold filter
        const smallBlur = document.querySelector('#round-corners-small feGaussianBlur');
        const largeBlur = document.querySelector('#round-corners-large feGaussianBlur');
        if (smallBlur) smallBlur.setAttribute('stdDeviation', HEX_CORNER_RADIUS * 0.1);
        if (largeBlur) largeBlur.setAttribute('stdDeviation', HEX_CORNER_RADIUS * 0.2);

        // Seeded random number generator
        let seed = 956637;

        // Check URL for seed parameter (for testing other layouts)
        const urlParams = new URLSearchParams(window.location.search);
        if (urlParams.has('seed')) {
            seed = parseInt(urlParams.get('seed'), 10);
            console.log('Seed:', seed);
        }

        function seededRandom() {
            seed = (seed * 1103515245 + 12345) & 0x7fffffff;
            return (seed / 0x7fffffff);
        }

        const canvasBack = document.getElementById('canvas-blur-back');
        const canvasMid = document.getElementById('canvas-blur-mid');
        const canvasSharp = document.getElementById('canvas-sharp');
        const ctxBack = canvasBack.getContext('2d');
        const ctxMid = canvasMid.getContext('2d');
        const ctxSharp = canvasSharp.getContext('2d');

        let width, height;
        let mouseX = 0;
        let mouseY = 0;
        let targetMouseX = 0;
        let targetMouseY = 0;

        const hexagons = [];
        const connections = [];
        const focusRadius = 250;
        const focusTransitionRadius = 150;

        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvasBack.width = canvasMid.width = canvasSharp.width = width;
            canvasBack.height = canvasMid.height = canvasSharp.height = height;
        }

        class Hexagon {
            constructor(x, y, size, layer) {
                this.baseX = x;
                this.baseY = y;
                this.x = x;
                this.y = y;
                this.size = size;
                this.layer = layer;
                this.parallaxFactor = 0.02 + layer * 0.015;
                this.opacity = 0.15 + seededRandom() * 0.5;
                this.rotation = seededRandom() * Math.PI * 2;
                this.rotationSpeed = (seededRandom() - 0.5) * 0.002;
                this.floatOffset = seededRandom() * Math.PI * 2;
                this.floatSpeed = 0.0005 + seededRandom() * 0.001;
                this.floatAmplitude = 5 + seededRandom() * 10;
                this.filled = seededRandom() > 0.7;
                this.glowIntensity = seededRandom();
                this.currentLayer = layer;
                this.targetLayer = layer;
            }

            update(time, timeScale = 1, fancyEffects = false) {
                const floatY = Math.sin(time * this.floatSpeed + this.floatOffset) * this.floatAmplitude;
                const floatX = Math.cos(time * this.floatSpeed * 0.7 + this.floatOffset) * this.floatAmplitude * 0.5;

                // Parallax only if FPS allows
                if (fancyEffects) {
                    const parallaxX = (mouseX - width / 2) * this.parallaxFactor;
                    const parallaxY = (mouseY - height / 2) * this.parallaxFactor;
                    this.x = this.baseX + parallaxX + floatX;
                    this.y = this.baseY + parallaxY + floatY;
                } else {
                    this.x = this.baseX + floatX;
                    this.y = this.baseY + floatY;
                }

                this.rotation += this.rotationSpeed * timeScale;

                // Focus effect only if FPS allows
                if (fancyEffects) {
                    const distToMouse = Math.hypot(this.x - mouseX, this.y - mouseY);
                    if (distToMouse < focusRadius) {
                        this.targetLayer = 2;
                    } else if (distToMouse < focusRadius + focusTransitionRadius) {
                        this.targetLayer = 1;
                    } else {
                        this.targetLayer = this.layer;
                    }
                } else {
                    this.targetLayer = this.layer;
                }

                const layerLerp = 1 - Math.pow(0.9, timeScale);
                this.currentLayer += (this.targetLayer - this.currentLayer) * layerLerp;
            }

            drawHexPath(ctx, size) {
                const vertices = [];
                for (let i = 0; i < 6; i++) {
                    const angle = (Math.PI / 3) * i - Math.PI / 2;
                    vertices.push({
                        x: Math.cos(angle) * size,
                        y: Math.sin(angle) * size
                    });
                }

                ctx.beginPath();
                if (HEX_CORNER_RADIUS > 0) {
                    const radius = HEX_CORNER_RADIUS * (size / this.size);
                    for (let i = 0; i < 6; i++) {
                        const curr = vertices[i];
                        const next = vertices[(i + 1) % 6];
                        if (i === 0) {
                            const prev = vertices[5];
                            const startX = prev.x + (curr.x - prev.x) * 0.5;
                            const startY = prev.y + (curr.y - prev.y) * 0.5;
                            ctx.moveTo(startX, startY);
                            ctx.arcTo(curr.x, curr.y, next.x, next.y, radius);
                        } else {
                            ctx.arcTo(curr.x, curr.y, next.x, next.y, radius);
                        }
                    }
                } else {
                    for (let i = 0; i < 6; i++) {
                        if (i === 0) {
                            ctx.moveTo(vertices[i].x, vertices[i].y);
                        } else {
                            ctx.lineTo(vertices[i].x, vertices[i].y);
                        }
                    }
                }
                ctx.closePath();
            }

            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);

                // Hex-shaped glow layers (same size, different lineWidth + blur)
                if (this.glowIntensity > 0.5) {
                    const glowLayers = [
                        { lineWidth: 12, blur: 15, opacity: 0.15 },
                        { lineWidth: 6, blur: 8, opacity: 0.25 },
                        { lineWidth: 3, blur: 4, opacity: 0.35 }
                    ];
                    for (const layer of glowLayers) {
                        this.drawHexPath(ctx, this.size);
                        ctx.strokeStyle = `rgba(94, 231, 231, ${this.opacity * layer.opacity})`;
                        ctx.lineWidth = layer.lineWidth;
                        ctx.shadowColor = 'rgba(94, 231, 231, 1)';
                        ctx.shadowBlur = layer.blur;
                        ctx.stroke();
                    }
                    ctx.shadowBlur = 0;
                }

                // Main hexagon
                this.drawHexPath(ctx, this.size);

                if (this.filled) {
                    ctx.fillStyle = `rgba(94, 231, 231, ${this.opacity * 0.15})`;
                    ctx.fill();
                }

                ctx.strokeStyle = `rgba(94, 231, 231, ${this.opacity})`;
                ctx.lineWidth = 1.5;
                ctx.stroke();

                ctx.restore();
            }
        }

        function init() {
            resize();
            hexagons.length = 0;
            connections.length = 0;

            const numHexagons = Math.floor((width * height) / 20000);

            for (let i = 0; i < numHexagons; i++) {
                const x = seededRandom() * width;
                const y = seededRandom() * height;
                const size = 15 + seededRandom() * 35;
                const layer = Math.floor(seededRandom() * 3);
                hexagons.push(new Hexagon(x, y, size, layer));
            }

            hexagons.sort((a, b) => a.layer - b.layer);

            for (let i = 0; i < hexagons.length; i++) {
                const hex1 = hexagons[i];
                for (let j = i + 1; j < hexagons.length; j++) {
                    const hex2 = hexagons[j];
                    const dist = Math.hypot(hex1.baseX - hex2.baseX, hex1.baseY - hex2.baseY);
                    if (dist < 200 && seededRandom() > 0.5) {
                        connections.push({
                            from: hex1,
                            to: hex2,
                            opacity: 0.2 + seededRandom() * 0.4,
                            layer: Math.min(hex1.layer, hex2.layer)
                        });
                    }
                }
            }
        }

        function drawConnections(ctx, layerFilter) {
            connections.forEach(conn => {
                const avgLayer = (conn.from.currentLayer + conn.to.currentLayer) / 2;

                if (layerFilter === 0 && avgLayer >= 0.7) return;
                if (layerFilter === 1 && (avgLayer < 0.7 || avgLayer >= 1.7)) return;
                if (layerFilter === 2 && avgLayer < 1.7) return;

                // Calculate direction and distance
                const dx = conn.to.x - conn.from.x;
                const dy = conn.to.y - conn.from.y;
                const dist = Math.hypot(dx, dy);

                if (dist < conn.from.size + conn.to.size) return;

                // Normalize direction
                const nx = dx / dist;
                const ny = dy / dist;

                // Offset start and end points by hex size (stop at edge)
                const startX = conn.from.x + nx * conn.from.size;
                const startY = conn.from.y + ny * conn.from.size;
                const endX = conn.to.x - nx * conn.to.size;
                const endY = conn.to.y - ny * conn.to.size;

                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.lineTo(endX, endY);
                ctx.strokeStyle = `rgba(94, 231, 231, ${conn.opacity})`;
                ctx.lineWidth = 1.5;
                ctx.stroke();
            });
        }

        function drawGradientOverlay(ctx) {
            const gradient = ctx.createRadialGradient(
                width * 0.5, height * 0.4, 0,
                width * 0.5, height * 0.4, Math.max(width, height) * 0.8
            );
            gradient.addColorStop(0, 'rgba(10, 15, 20, 0)');
            gradient.addColorStop(0.5, 'rgba(10, 15, 20, 0.3)');
            gradient.addColorStop(1, 'rgba(10, 15, 20, 0.8)');

            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, width, height);
        }

        function clearCanvas(ctx) {
            ctx.clearRect(0, 0, width, height);
        }

        // Adaptive frame timing and performance
        let lastTime = 0;
        let animTime = 0;
        const targetFrameTime = 1000 / 60; // 60fps target

        // FPS tracking for adaptive effects
        let fpsHistory = [];
        let avgFps = 60;
        let enableFancyEffects = true;
        const FPS_THRESHOLD = 45; // Below this, disable fancy effects

        function animate(time) {
            // Calculate delta and adapt animation speed
            const deltaTime = lastTime ? time - lastTime : targetFrameTime;
            lastTime = time;

            // Track FPS and adapt effects
            const currentFps = 1000 / deltaTime;
            fpsHistory.push(currentFps);
            if (fpsHistory.length > 30) fpsHistory.shift(); // Keep last 30 frames
            avgFps = fpsHistory.reduce((a, b) => a + b, 0) / fpsHistory.length;
            enableFancyEffects = avgFps > FPS_THRESHOLD;

            // Scale animation by how much time actually passed vs target
            const timeScale = Math.min(deltaTime / targetFrameTime, 3); // Cap at 3x to prevent jumps
            animTime += targetFrameTime * timeScale;

            ctxBack.fillStyle = '#0a0f14';
            ctxBack.fillRect(0, 0, width, height);
            clearCanvas(ctxMid);
            clearCanvas(ctxSharp);

            // Smooth mouse follow with adaptive timing
            const mouseLerp = 1 - Math.pow(0.92, timeScale);
            mouseX += (targetMouseX - mouseX) * mouseLerp;
            mouseY += (targetMouseY - mouseY) * mouseLerp;

            hexagons.forEach(hex => hex.update(animTime, timeScale, enableFancyEffects));

            // Draw back layer (blurred)
            drawConnections(ctxBack, 0);
            hexagons.forEach(hex => {
                if (hex.currentLayer < 0.7) {
                    hex.draw(ctxBack);
                }
            });

            // Draw mid layer (slightly blurred)
            drawConnections(ctxMid, 1);
            hexagons.forEach(hex => {
                if (hex.currentLayer >= 0.7 && hex.currentLayer < 1.7) {
                    hex.draw(ctxMid);
                }
            });

            // Draw sharp layer (focused)
            drawConnections(ctxSharp, 2);
            hexagons.forEach(hex => {
                if (hex.currentLayer >= 1.7) {
                    hex.draw(ctxSharp);
                }
            });

            drawGradientOverlay(ctxSharp);

            requestAnimationFrame(animate);
        }

        window.addEventListener('resize', () => {
            resize();
            init();
        });

        window.addEventListener('mousemove', (e) => {
            targetMouseX = e.clientX;
            targetMouseY = e.clientY;
        });

        window.addEventListener('touchmove', (e) => {
            targetMouseX = e.touches[0].clientX;
            targetMouseY = e.touches[0].clientY;
        });

        init();
        targetMouseX = width / 2;
        targetMouseY = height / 2;
        mouseX = targetMouseX;
        mouseY = targetMouseY;
        requestAnimationFrame(animate);
    </script>
</body>
</html>
