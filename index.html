<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Grafema â€” Graph-Driven Development</title>
    <meta name="description" content="Represent your codebase as a queryable graph. Define guarantees, track dependencies, catch violations before they ship.">
    <meta name="theme-color" content="#0a0e17">
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg viewBox='0 0 173 196' xmlns='http://www.w3.org/2000/svg'%3E%3Cg stroke='%2300D9FF' stroke-width='2.5' fill='%2300D9FF'%3E%3Cpath d='M86 3.14 L166.61 49.95 L166.35 68.72 H155.31 L155.06 56.36 L86 16.4 L16.61 58.12 L16.13 139.89 L86 180.58 L154.76 140.3 L155.07 102.45 L92.96 101.98 L92.71 111.75 H82.66 L82.21 90.74 L166.03 91.21 L165.87 147.59 L86 194.12 L4.18 145.43 L4.87 51.79 Z'/%3E%3Cpath d='M86 33.74 L139.59 64.66 L139.59 68.48 H123.01 L86 46.77 L42.67 72.21 L42.28 125.69 L86 150.75 L129.32 125.46 L129.51 116.98 H140.04 L140.14 133 L86 163.65 L30.65 131.75 L30.73 65.89 Z'/%3E%3C/g%3E%3C/svg%3E">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg: #0a0e17;
            --cyan: #00D9FF;
            --cyan-glow: rgba(0, 217, 255, 0.3);
            --cyan-subtle: rgba(0, 217, 255, 0.12);
            --text: #ffffff;
            --text-secondary: rgba(255, 255, 255, 0.65);
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg);
            color: var(--text);
            min-height: 100vh;
            overflow-x: hidden;
            line-height: 1.6;
        }

        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            display: block;
        }

        .wrapper {
            position: relative;
            z-index: 1;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1.5rem 3rem;
        }

        .logo-container {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .logo {
            width: 36px;
            height: 36px;
            filter: drop-shadow(0 0 12px var(--cyan-glow));
        }

        .logo-text {
            font-size: 1.25rem;
            font-weight: 600;
            color: var(--cyan);
            letter-spacing: 0.01em;
            text-shadow: 0 0 20px var(--cyan-glow);
        }

        main {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            padding: 2rem 2rem 4rem;
        }

        .badge {
            display: inline-flex;
            align-items: center;
            gap: 0.4rem;
            padding: 0.35rem 0.75rem;
            font-size: 0.7rem;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: var(--cyan);
            background: var(--cyan-subtle);
            border: 1px solid rgba(0, 217, 255, 0.2);
            border-radius: 100px;
            margin-bottom: 1.5rem;
        }

        .badge::before {
            content: '';
            width: 6px;
            height: 6px;
            background: var(--cyan);
            border-radius: 50%;
            box-shadow: 0 0 6px var(--cyan);
        }

        h1 {
            font-size: clamp(2.5rem, 6vw, 3.75rem);
            font-weight: 700;
            letter-spacing: -0.03em;
            line-height: 1.1;
            margin-bottom: 1.25rem;
        }

        .description {
            font-size: clamp(1rem, 2vw, 1.15rem);
            color: var(--text-secondary);
            max-width: 560px;
            margin-bottom: 2.5rem;
            line-height: 1.7;
        }

        .buttons {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            justify-content: center;
        }

        .btn {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.8rem 1.5rem;
            border-radius: 8px;
            text-decoration: none;
            font-weight: 500;
            font-size: 0.9rem;
            transition: all 0.25s ease;
        }

        .btn-secondary {
            background: transparent;
            color: var(--text);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.05);
            border-color: rgba(255, 255, 255, 0.3);
        }

        .btn-primary {
            background: var(--cyan);
            color: var(--bg);
            border: 1px solid var(--cyan);
            box-shadow: 0 0 20px var(--cyan-glow);
        }

        .btn-primary:hover {
            background: #fff;
            border-color: #fff;
            box-shadow: 0 0 30px var(--cyan-glow);
            transform: translateY(-1px);
        }

        .decoration {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            width: 24px;
            height: 24px;
            opacity: 0.3;
        }

        @media (max-width: 640px) {
            header { padding: 1rem 1.5rem; }
            main { padding: 1.5rem 1.5rem 3rem; }
            .buttons { flex-direction: column; width: 100%; max-width: 280px; }
            .btn { justify-content: center; }
            .decoration { display: none; }
        }
    </style>
</head>
<body>
    <canvas id="canvas-container"></canvas>

    <div class="wrapper">
        <header>
            <div class="logo-container">
                <!-- Grafema Logo -->
                <svg class="logo" viewBox="0 0 173 196" xmlns="http://www.w3.org/2000/svg">
                    <g stroke="#00D9FF" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" fill="#00D9FF">
                        <!-- Outer hexagon with G cutout -->
                        <path d="M86 3.14 L166.61 49.95 L166.35 68.72 H155.31 L155.06 56.36 L86 16.4 L16.61 58.12 L16.13 139.89 L86 180.58 L154.76 140.3 L155.07 102.45 L92.96 101.98 L92.71 111.75 H82.66 L82.21 90.74 L166.03 91.21 L165.87 147.59 L86 194.12 L4.18 145.43 L4.87 51.79 Z"/>
                        <!-- Inner hexagon with G cutout -->
                        <path d="M86 33.74 L139.59 64.66 L139.59 68.48 H123.01 L86 46.77 L42.67 72.21 L42.28 125.69 L86 150.75 L129.32 125.46 L129.51 116.98 H140.04 L140.14 133 L86 163.65 L30.65 131.75 L30.73 65.89 Z"/>
                    </g>
                </svg>
                <span class="logo-text">grafema</span>
            </div>
        </header>

        <main>
            <div class="badge">In Development</div>
            <h1>Graph-Driven Development</h1>
            <p class="description">
                Represent your codebase as a queryable graph.
                Define guarantees, track dependencies, catch violations before they ship.
            </p>
            <div class="buttons">
                <a href="https://github.com/Disentinel/grafema" class="btn btn-secondary" target="_blank" rel="noopener">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/>
                    </svg>
                    View on GitHub
                </a>
                <a href="https://doi.org/10.5281/zenodo.18247579" class="btn btn-primary" target="_blank" rel="noopener">
                    Read the Paper
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M7 17L17 7"/><path d="M7 7h10v10"/>
                    </svg>
                </a>
            </div>
        </main>

        <svg class="decoration" viewBox="0 0 40 40" fill="none">
            <path d="M20 0 L26 14 L40 20 L26 26 L20 40 L14 26 L0 20 L14 14 Z" fill="#00D9FF"/>
        </svg>
    </div>

    <script>
        const CONFIG = {
            nodeCount: 120,
            connectionDist: 85,
            nodeRadiusMin: 2.5,
            nodeRadiusMax: 7,
            driftSpeed: 0.4,
            cyan: '#00D9FF'
        };

        const canvas = document.getElementById('canvas-container');
        const ctx = canvas.getContext('2d', { alpha: false });
        let w = canvas.width = window.innerWidth;
        let h = canvas.height = window.innerHeight;

        // Particles
        const particles = [];
        for (let i = 0; i < CONFIG.nodeCount; i++) {
            particles.push({
                x: Math.random() * w,
                y: Math.random() * h,
                vx: (Math.random() - 0.5) * CONFIG.driftSpeed,
                vy: (Math.random() - 0.5) * CONFIG.driftSpeed,
                r: CONFIG.nodeRadiusMin + Math.random() * (CONFIG.nodeRadiusMax - CONFIG.nodeRadiusMin),
                baseOpacity: 0.25 + Math.random() * 0.35,
                phase: Math.random() * Math.PI * 2,
                pulseSpeed: 0.008 + Math.random() * 0.015
            });
        }

        // Noise function
        const noiseTab = Array.from({ length: 256 }, () => Math.random());
        function noise(x, y) {
            const xi = Math.floor(x) & 255;
            const yi = Math.floor(y) & 255;
            const xf = x - Math.floor(x);
            const yf = y - Math.floor(y);
            const u = xf * xf * (3 - 2 * xf);
            const v = yf * yf * (3 - 2 * yf);
            const n0 = noiseTab[(xi + noiseTab[yi]) & 255];
            const n1 = noiseTab[(xi + 1 + noiseTab[yi]) & 255];
            const ix = n0 + u * (n1 - n0);
            const n2 = noiseTab[(xi + noiseTab[(yi + 1) & 255]) & 255];
            const n3 = noiseTab[(xi + 1 + noiseTab[(yi + 1) & 255]) & 255];
            const iy = n2 + u * (n3 - n2);
            return ix + v * (iy - ix);
        }

        let time = 0;

        function draw() {
            // Background
            ctx.fillStyle = '#0a0e17';
            ctx.fillRect(0, 0, w, h);

            // Update and draw particles
            for (let i = 0; i < particles.length; i++) {
                const p = particles[i];

                // Brownian motion
                p.vx += (Math.random() - 0.5) * 0.025;
                p.vy += (Math.random() - 0.5) * 0.025;
                const speed = Math.sqrt(p.vx * p.vx + p.vy * p.vy);
                if (speed > 2.5) {
                    p.vx *= 0.92;
                    p.vy *= 0.92;
                }

                p.x += p.vx;
                p.y += p.vy;

                // Wrap around with padding
                const pad = 40;
                if (p.x < -pad) p.x = w + pad;
                if (p.x > w + pad) p.x = -pad;
                if (p.y < -pad) p.y = h + pad;
                if (p.y > h + pad) p.y = -pad;

                // Pulse with noise modulation
                p.phase += p.pulseSpeed;
                const noiseMod = noise(p.x * 0.001 + time * 0.001, p.y * 0.001) * 0.5;
                const pulseAmount = Math.sin(p.phase + noiseMod * Math.PI) * 0.35;
                const opacity = Math.max(0.08, Math.min(0.65, p.baseOpacity + pulseAmount));

                // Draw outer glow
                const g1 = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.r * 2.5);
                g1.addColorStop(0, `rgba(0, 217, 255, ${opacity * 0.4})`);
                g1.addColorStop(0.6, `rgba(0, 217, 255, ${opacity * 0.1})`);
                g1.addColorStop(1, `rgba(0, 217, 255, 0)`);
                ctx.fillStyle = g1;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.r * 2.5, 0, Math.PI * 2);
                ctx.fill();

                // Draw core with bloom
                const g2 = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.r * 1.3);
                g2.addColorStop(0, `rgba(0, 217, 255, ${opacity})`);
                g2.addColorStop(1, `rgba(0, 217, 255, ${opacity * 0.5})`);
                ctx.fillStyle = g2;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
                ctx.fill();
            }

            // Draw edges with blur and bloom
            ctx.lineWidth = 1.2;
            for (let i = 0; i < particles.length; i++) {
                for (let j = i + 1; j < particles.length; j++) {
                    const p1 = particles[i];
                    const p2 = particles[j];
                    const dx = p2.x - p1.x;
                    const dy = p2.y - p1.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < CONFIG.connectionDist) {
                        const falloff = (1 - dist / CONFIG.connectionDist);
                        const opacity = falloff * falloff * 0.16;

                        // Draw noisy path
                        ctx.strokeStyle = `rgba(0, 217, 255, ${opacity})`;
                        ctx.beginPath();
                        ctx.moveTo(p1.x, p1.y);

                        const steps = 7;
                        for (let k = 1; k <= steps; k++) {
                            const t = k / steps;
                            const x = p1.x + dx * t;
                            const y = p1.y + dy * t;
                            const noiseX = (noise(x * 0.0035 + time * 0.0008, y * 0.0035) - 0.5) * 4;
                            const noiseY = (noise(x * 0.0035, y * 0.0035 + time * 0.0008) - 0.5) * 4;
                            ctx.lineTo(x + noiseX, y + noiseY);
                        }
                        ctx.stroke();

                        // Bloom layer - slightly blurred/thicker
                        ctx.lineWidth = 2.4;
                        ctx.strokeStyle = `rgba(0, 217, 255, ${opacity * 0.5})`;
                        ctx.beginPath();
                        ctx.moveTo(p1.x, p1.y);
                        for (let k = 1; k <= steps; k++) {
                            const t = k / steps;
                            const x = p1.x + dx * t;
                            const y = p1.y + dy * t;
                            const noiseX = (noise(x * 0.0035 + time * 0.0008, y * 0.0035) - 0.5) * 4;
                            const noiseY = (noise(x * 0.0035, y * 0.0035 + time * 0.0008) - 0.5) * 4;
                            ctx.lineTo(x + noiseX, y + noiseY);
                        }
                        ctx.stroke();
                    }
                }
            }

            // Fog effect - subtle vignette
            const fogGrad = ctx.createRadialGradient(w / 2, h / 2, 0, w / 2, h / 2, Math.max(w, h) * 0.7);
            fogGrad.addColorStop(0, 'rgba(10, 14, 23, 0)');
            fogGrad.addColorStop(0.85, 'rgba(10, 14, 23, 0.15)');
            fogGrad.addColorStop(1, 'rgba(10, 14, 23, 0.35)');
            ctx.fillStyle = fogGrad;
            ctx.fillRect(0, 0, w, h);

            time += 1;
            requestAnimationFrame(draw);
        }

        window.addEventListener('resize', () => {
            w = canvas.width = window.innerWidth;
            h = canvas.height = window.innerHeight;
        });

        draw();
    </script>
</body>
</html>
